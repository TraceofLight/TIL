### 문제의 정의

- 현재의 상태 변화로 인하여 목표 상태가 생기는 것
- 복잡도, 해결가부, 반복성 등으로 구분

### 문제의 해결

- 해결을 위해 시간, 노력, 사고의 투입
- 투입 정도에 따른 결과물의 질적 차이

### 문제의 해결 과정

- 문제에서 문제해결 상태에 도달하기 위한 일련의 처리 및 사고 과정을 순차적으로 나열한 것

### 문제 유형

- 일반적 문제
- 컴퓨팅 기반 문제

#### 컴퓨팅 기반 문제 유형

- 결정 문제
- 탐색 문제
- 연산 가능한 문제
- 최적화 문제

### 일반적인 문제 해결 과정

- 문제 이해 > 해결방안 고안 > 해결책 선택 > 실행 및 평가

  - 문제 이해 : 조건과 정보에 대한 바른 이해, 논리적 사고 & 통합적 사고의 필요

  - 해결방안 고안 : 문제를 해결할 당사자의 경험 및 지식에 따른 다양한 아이디어 존재, 확장된 사고 필요, 다양한 자료의 수집과 탐색이 기반이 되어 다양한 해결방안을 도출 가능

  - 해결책 선택 : 해결책 선택을 위한 수렴적 사고의 필요성 (수렴적 사고 : 다양한 해결 방안 중에서 더 유용하고 효율적이며 가치 있는 것을 선택하기 위한 사고)

  - 실행 및 평가 : 과정 중 문제가 발생할 경우 되돌아가 해결책의 문제, 이해 착오 등을 확인해야 함, 목표치에 도달하지 못한 경우도 문제를 확인, 실행 이후 평가는 다음 문제해결의 실행을 위한 중요한 자료

### 컴퓨팅 기반 문제 해결 과정

- 문제 이해 > 해결과정 설계 > 프로그래밍 구현 > 결과물 확인

  - 문제 이해 : 문제의 요구 상황에 대한 정확한 파악, 자료의 수집, 문제의 재정의

  - 해결과정 설계 : 알고리즘, 명확한 의미를 갖는 용어로 기술, 절차간 효율적 처리가 가능하도록 기술, 시작과 끝이 반드시 포함, 표현 방식으로는 자연어, 의사코드, 순서도 등이 존재

  - 프로그래밍 구현 : 컴퓨터를 사용하여 결과를 만들어내는 과정 '자동화'

  - 결과물 확인 : 작성한 프로그램에 실제 데이터값을 입력, 처리하여 원하는 결과가 도출되었는지 확인, 실행결과에 대한 검토 및 보안, 효율성에 대한 검토

### 선택정렬

가장 작은 것을 선택해서 제일 앞으로 보내는 알고리즘
시간복잡도 O(N^2) << 연산 횟수의 최고차항

### 버블정렬

옆에 있는 값과 비교할 때 더 작은 값을 앞으로 보내는 알고리즘
시간복잡도 O(N^2)

### 삽입정렬

각 숫자를 적절한 위치에 삽입하는 방법, 정렬된 상태의 경우 매우 빠름
시간복잡도 O(N^2)

### 퀵정렬

시간복잡도 O(N\*logN) 이나 이미 정렬이 된 케이스일 경우 O(N^2) 에 수렴한다.

1. Pivot값을 설정
2. 왼쪽에서부터 해당 값보다 큰 숫자 서치, 오른쪽에서부터 해당 값보다 작은 값 서치
3. 두 값을 교체
4. 반복하다가 큰 값이 작은 값보다 오른쪽에 위치할 경우, Pivot값과 작은 값의 위치를 교환
5. Pivot값을 기준으로 좌우 크기 갈리며 다시 퀵정렬 반복

### 병합정렬

큰 문제를 작은 문제 2개로 분할하고 이후 정렬하는 방식
일단 최소단위까지 계속 반으로 쪼갠 이후 결합하면서 정렬
시간복잡도 O(N\*logN)

### 힙정렬

힙 트리 구조를 이용하는 정렬 방법  
이진 트리 : 모든 노드의 자식 노드가 2개 이하인 트리 구조  
완전 이진 트리 : 자식 노드가 차근차근 들어가서 순서대로 차는 2진 트리 구조
최대 힙 구조 : 이진 트리 기반 부모 노드가 자식 노드보다 큰 힙  
힙 생성 알고리즘 : 특정 노드의 두 자식 중 더 큰 자식과 자신의 위치를 바꾸는 알고리즘

최대 힙 구성을 한 이후 Root 값을 맨 뒤의 값과 교체하면서 트리의 크기를 줄여나가는 과정

시간 복잡도 O(N\*logN)
속도 자체는 퀵정렬이 평균적으로 우위

### 계수 정렬

시간복잡도 O(N)  
범위 조건이 있는 경우에 한하여 매우 빠른 알고리즘  
숫자를 하나하나 범위 조건과 대조하면서 체크 후 갯수대로 순서 출력
